============================================================  LAYER 0 Interface (raw TCP/timer layer) =======================================================

Layer 0 is the lowest layer in our application, this is where language specific decisions are
made about threads/blocking/nonblocking/asynchronous architecture. The only requirements of code
that uses layer 0 are that it have handlers for the various events that can be generated by
layer 0 and requires only the callbacks exported by layer 0.  Code that relies on layer zero is
assumed to be and treated as non-reentrant, meaning that events cannot be delivered simultaneously
by multiple threads, and a correct implementation of layer zero should respect this.
Additionally, layer zero guarantees that sequential writes to a TCP connection will be
sent in-order, but makes no guarantees about how long it will take to send.

INPUT EVENTS:
scheduleTimout(obj, time)--schedule a timeout in the future with a given timeout object
sendDataOverConnection(connection, data)--send data over the given TCP connection
createNewTcpConnection(targethost, targetport, requestKey)--create a new TCP connection with the
                                                            target host, also need a requestKey,
                                                            once the connection creation succeeds/fails,
                                                            the event that indicates this will use the key
                                                            to identify the request
closeTcpConnection(connection)--close connection by sending FIN packet

OUTPUT EVENTS:
init() --called once at the beginning, because program has to do some initial stuff then
newHTTPTcpConnection(connection) --called when a new TCP connection comes in related to HTTP
newTorTcpConnection(connection)--called when a new TCP connection comes in related to Tor
dataFromTcpConnection(connection, data)--called when data comes in for a connection, either TCP or Tor
tcpConnectionDown(connection)--called when an existing TCP connection is no longer responsive,
                               this could either be because we received a FIN (which we replied to)
                               or because we tried to send data over a TCP connection but it timed out
timeoutReceived(obj)--previously scheduled timeout has expired, obj is what we scheduled with
shutdown() -- called once at the end, indicating that the process is being shut down, probably
              the right thing to do here is to just close all TCP connections by sending FIN
createNewTcpConnectionSucceeded(requestKey, connection)--indicates that an earlier request to create a
                                                         connection succeeded
createNewTcpConnectionFailed(requestKey)--indicates that an earlier request to create a connection failed



===================================================================  LAYER 1 (Tor cell layer) ============================================================


In our application, there will be three stacks sitting on top of layer 0, this will be the
Tor stack, the registration server stack, and the Http stack.  This document is concerned
with the Tor stack, and the Tor cell layer is the first layer of the Tor stack.  It provides
a view of Tor cells being transmitted over TCP connections.

INPUT EVENTS FROM LAYER 0:
init()
newHTTPTcpConnection(connection)
newTorTcpConnection(connection)
dataFromTcpConnection(connection, data)
tcpConnectionDown(connection)
timeoutReceived(obj)
shutdown()
createNewTcpConnectionSucceeded(requestKey, connection)
createNewTcpConnectionFailed(requestKey)


OUTPUT EVENTS TO LAYER 0:
scheduleTimout(obj, time)
sendDataOverConnection(connection, data)
createNewTcpConnection(targethost, targetport, requestKey)
closeTcpConnection(connection)

OUTPUT EVENTS TO HIGHER LAYER:
newTorTcpConnection(connection)--same as the event from the lower layer (although we can choose
                                 to pass a different connection object as long as we can map
                                 it back to the original connection object), this indicates that
                                 there is a new Tor TCP connection as a result of a client connecting
                                 to us

openPacketReceived(connection, srcAgentId, destAgentId)--indicates an open packet was received
                                                         on the given connection, with the given
                                                         src/dest agent ID's

openedPacketReceived(connection, srcAgentId, destAgentId)--indicates an opened packet was received
                                                           on the given connection, with the given
                                                           src/dest agent ID's

openedFailedReceived(connection, srcAgentId, destAgentId)--indicates an openFailed packet was received
                                                           on the given connection, with the given
                                                           src/dest agent ID's

createReceived(connection, circuitId)--indicates a create packet was received from the given
                                       connection with the given circuit id

createdReceived(connection, circuitId)--indicates a create packet was received from the given
                                        connection with the given circuit id

createFailedReceived(connection, circuitId)--indicates a createFailed packet was received from the given
                                             connection with the given circuit id

destroyReceived(connection, circuitId)--indicates a destroy packet was received from the given
                                        connection with the given circuit id

relayReceived(connection, circuitId, rest)--indicates that a relay packet was received on the given connection
                                            with the given circuitId and with content "rest", where "rest" is
                                            all of the data in the packet minus the first two bytes (the circuit id)
                                            NOTE: The decision being made here is to parse the contents of the
                                            relay packet at a higher layer, this is because we actually only ever
                                            need to parse it if it is destined for us, so it should be slightly
                                            more efficient?
torTcpConnectionDown(connection) -- indicates that the given Tor tcp connection is down, either we received a
                                    FIN from the other side, or there was a failure/timeout when we tried to send data

createNewTorTcpConnectionSucceeded(requestKey, connection)--indicates that an earlier request to create a
                                                            connection succeeded
createNewTorTcpConnectionFailed(requestKey)--indicates that an earlier request to create a connection failed

init() --called once at the beginning, because program has to do some initial stuff then




INPUT EVENTS FROM HIGHER LAYER:
GENERAL STATEMENT: For each "received" event above that we can generate at this layer, we have
a "send" event that we can receive from the next layer up, it's basically just the inverse...
sendOpenPacket(connection, srcAgentId, destAgentId)
sendOpenedPacket(connection, srcAgentId, destAgentId)
sendOpenedFailed(connection, srcAgentId, destAgentId)
sendCreate(connection, circuitId)
sendCreated(connection, circuitId)
sendCreateFailed(connection, circuitId)
sendDestroy(connection, circuitId)
sendRelay(connection, circuitId, rest)

createTorTcpConnection(host, portnum, requestKey) -- Request to create a Tor TCP connection
closeTorTcpConnection(connection) -- Request to close Tor TCP connection


IMPLEMENTATION (NOTE: I changed the interface so this might need to be modified):
We maintain two hashmaps, one that maps HttpTcpConnections to something (figure out later), another
that maps TorTcpConnections to objects that will be described here.

Each time we receive a newHTTPTcpConnection() event, we put the new connection in the hash HttpTcpConnections
hashmap, with whatever object we decide on later as the value.

Each time we receive a newTorTcpConnection() event, we put the new connection in the TorTcpConnections hash
map.  The value should be a 512 byte buffer (with an int that can index to our current location in the buffer).

Each time we receive a dataFromTcpConnection(connection, data) event, we check, is the connection a key in
the TorTcpConnections hashmap?  If so, then we place the data in the buffer until it fills up.  Each time the
buffer fills up, we then have to decode the binary information in the buffer and generate an "XPacketReceived"
event for the cell layer.

Each time we receive a "sendXPacket" event from the higher layer, then we just binary encode the information
given into 512 bits, and send it out the Tcp connection.

Note that here we have a choice as to what "connection" object we pass to the higher layer.  In this case, I
think it's probably fine to just pass the same Tcp connection we get from below.  An alternate scheme would
be to pass the pointer to the hashmap value, but then we would want the hashmap value to contain a pointer to
the tcp socket.  At this layer there's probably no reason to do this, but it might have advantages in a higher
layer, not sure.

Also, for createTorTcpConnection(agentId), we'll need to have access to a table mapping agent numbers to ip/pornum
pairs, also the connections created here will have to go into our hashmap before we return to the higher
layer that called.

===============================================================  LAYER 2 (Tor Connection Layer) =========================================================

This layer introduces the abstraction of a "Tor connection"--which is a TCP connection for which the OPEN/OPENED
handshake has already occurred.  If the higher layer requests a new Tor connection be created, then this layer
will start the TCP connection, once this is up, it will send OPEN, and wait for OPENED.  Only then will it send
an event to the higher layer indicating that the connection was opened successfully, any other outcome and it
indicates failure.
Based on the specifications, there does not seem to be any application layer protocol for closing Tor connections,
so probably just Tcp close (i.e., send Tcp FIN).
Once a Tor connection exists, we can send channel create/created/createfailed/destroy packets, and also relay
packets.  Channel packets will be handled on the channel layer, relay packets above that one

INPUT EVENTS FROM LAYER 1 (explained above):
newTorTcpConnection(connection)
openPacketReceived(connection, srcAgentId, destAgentId)
openedPacketReceived(connection, srcAgentId, destAgentId)
openedFailedReceived(connection, srcAgentId, destAgentId)
createReceived(connection, circuitId)
createdReceived(connection, circuitId)
createFailedReceived(connection, circuitId)
destroyReceived(connection, circuitId)
relayReceived(connection, circuitId, rest)
torTcpConnectionDown(connection)
createNewTorTcpConnectionSucceeded(requestKey, connection)
createNewTorTcpConnectionFailed(requestKey)
init()

OUTPUT EVENTS TO LAYER 1 (explained above):
sendOpenPacket(connection, srcAgentId, destAgentId)
sendOpenedPacket(connection, srcAgentId, destAgentId)
sendOpenedFailed(connection, srcAgentId, destAgentId)
sendCreate(connection, circuitId)
sendCreated(connection, circuitId)
sendCreateFailed(connection, circuitId)
sendDestroy(connection, circuitId)
sendRelay(connection, circuitId, rest)
createTorTcpConnection(host, portnum)
closeTorTcpConnection(connection)

OUTPUT EVENTS TO TOR CONNECTION LAYER:
newTorConnection(connection, agentId)--We generate this when a new Tor connection
                                       has been successfully created which was initiated
                                       by the other party, i.e., we've
                                       done the application layer 2-way handshake
                                       and it's succeeded.  We provide the agentId
                                       of the agent at the other end of the connection
torConnectionCreated(connRequestKey, connection)--This is an event that indicates that
                                                  a new connection has been established
                                                  which was initiated by us, not by the
                                                  other party.  The "connRequestKey" was
                                                  an object provided by the higher layer
                                                  with the original request.
torConnectionFailed(connRequestKey)            -- This is an event that indicates that
                                                  a connection requested by the higher
                                                  did not succeed, but failed, the key
                                                  indicates the connection request that
                                                  failed
init() --called once at the beginning, because program has to do some initial stuff then

The following output events are just relayed from the lower layer:
(NOTE: Maybe rename some of these with "channel", like "createChannelReceived"?)
createReceived(connection, circuitId)
createdReceived(connection, circuitId)
createFailedReceived(connection, circuitId)
destroyReceived(connection, circuitId)
relayReceived(connection, circuitId, rest)
torConnectionDown(connection)--happens if the tor connection is closed or fails,
                               pretty much exactly when the TCP connection fails



INPUT EVENTS FROM TOR CONNECTION LAYER:
createTorConnection(host, portnum, agentId, connRequestKey)--Used to request that a connection be established
                                                             to another Tor agent, with the given host/portnum/agentId.
                                                             The connRequestKey is an
                                                             object which we will hand back to the higher layer
                                                             when the request either succeeds or fails.
                                                             Also, theoretically after the connection is established,
                                                             we can throw away the host/portnum info, but it might
                                                             make sense to cache this for future sanity checking, not sure..

The following input events are basically just transparently shunted
through to the lower layer:
(NOTE: Maybe rename some of these with "channel", like "sendCreateChannel"?)
sendCreate(connection, circuitId)
sendCreated(connection, circuitId)
sendCreateFailed(connection, circuitId)
sendDestroy(connection, circuitId)
sendRelay(connection, circuitId, rest)
destroyTorConnection(connection)

IMPLEMENTATION (NOTE: I changed the interface so this might need to be modified):

Maintain three hashmaps, one for TorTcpConnections, and two hashmaps that associate
connectionRequests with tor tcp connections (or a different way, basically given a
connection request, we need to find the assocated tcp connection, and vice versa, this
can be done with two hashmaps).

If the lower layer reports a new torTcpConnection, then we put it in the the torTcpConnection
hashmap, along with an object (as the value) that indicates the state of the handshake.  There
is no connection request object in this case.

If the upper layer requests createTorConnection(), then we call the lower layer createTorTcpConnection()
to get a new connection.  The connection goes into TorTcpConnections along with an object that
tracks its handshake state.  Also, we associate the connection with the connectionRequest object
from the higher layer.

If we get a handshake packet on a connection (open/opened/openFailed), then we advance the
handshake status of that connection.  If the connection was initiated by the other party, then
when the handshake succeeds, we generate a "newTorConnection" object for the higher layer, if
it fails we just don't create an object.  If the connection was initiated by us in response
to a request from the higher layer, then on success we generate a "torConnectionCreated(connRequestKey, connection)"
with the key that was provided from the higher layer, and the connection object.  We can
now delete the connection object at this layer.  If it failed, it's the same thing, but
we user "torConnectionFailed".

Also at this layer we should check that open/opened/openfailed packets only occur during the
handshake phase, and that they occur in the right order.  If these packets occur after the
handshake phase, then this is strange (drop packet?  log?  Choose what to do at this layer...)
Also make sure that if a non-handshake packet occurs, it happens after the handshake is complete,
otherwise the upper layer will be confused (maybe drop if this happens? Make decision at this
layer, don't pass up unless the handshake is complete...)

=================================================================  LAYER 3 (channel layer) ==========================================================

The channel layer implements an interface where instead of establishing Tor connections
and sending channel packets, we establish channels between Tor servers.  These channels
are actually multiplexed over Tor connections, but this is invisible to the user.
The user will request to create/destroy channels with other Tor nodes.  In this layer,
we will decide, do we already have a Tor connection, if not create it.  Also, if
all channels to another Tor node are destroyed, should we destroy the Tor connection?
This decision is made here as well.
The only data that goes over channels are relays, which are treated as opaque 510 byte
blocks.  It's up to the higher layer to parse them, the reason is that in many cases
the data doesn't have to be parsed, and is just routed from one channel to another.
(ALSO: the channel layer must keep track for each Tor connection of whether it was
initiated by us, or the other side.  This is how we will know to choose even vs. odd channel
ids.)

INPUT EVENTS FROM TOR CONNECTION LAYER (explained above):
newTorConnection(connection, agentId)
torConnectionCreated(connRequestKey, connection)
torConnectionFailed(connRequestKey)
createChannelReceived(connection, circuitId)
channelCreatedReceived(connection, circuitId)
createChannelFailedReceived(connection, circuitId)
destroyChannelReceived(connection, circuitId)
relayReceived(connection, circuitId, rest)
torConnectionDown(connection)
init()

OUTPUT EVENTS TO TOR CELL LAYER (explained above):
createTorConnection(host, portnum, agentId, connRequestKey)
sendCreateChannel(connection, circuitId)
sendChannelCreated(connection, circuitId)
sendCreateChannelFailed(connection, circuitId)
sendDestroyChannel(connection, circuitId)
sendRelay(connection, circuitId, rest)
destroyTorConnection(connection)


INPUT EVENTS FROM HIGHER LAYER:
createChannel(host, portnum, agentId, connRequestKey)--request the creation of
                                                       a new channel to the given
                                                       agent with the given host/portnum.
                                                       (Note that the agentId is redundant,
                                                       we can use this at the handshake layer
                                                       for sanity checking)
sendRelayOverChannel(channel, relaydat)--the "relaydat" parameter is exactly
                                         510 bytes, the 512 bytes of the
                                         relay cell, minus the first two
                                         bytes which specify the circuit
                                         ID.  Sending the relay over a
                                         channel will cause the correct
                                         two bytes to be generated by this
                                         layer (specifically, the channel ID)
destroyChannel(channel) -- destroy the channel

OUTPUT EVENTS TO HIGHER LAYER:
newChannelCreated(channel)--indicates that a new channel now exists which
                            was initiated by another agent
channelCreationSucceeded(channel, connRequestKey)--an earlier channel creation
                                                   request was successful
channelCreationFailed(connRequestKey)--an earlier channel creation
                                       request failed
channelDown(channel) -- The given channel is no longer working because it
                        was lost at the other end (we received a channel
                        close, there was a TCP write failure, TCP FIN, etc.)

relayReceivedFromChannel(channel, relaydat) -- relay data came in on the given
                                               channel, note that this data is
                                               exactly 510 bytes, basically the
                                               512 byte relay cell with the first
                                               two bytes removed
init() --called once at the beginning, because program has to do some initial stuff then

=================================================================  LAYER 4 (stream layer) ==========================================================

The stream layer is the top layer of the Tor stack.  The view from above this layer is that
Tor streams can be created by us or other agents, then can be used to carry data, and they
can be closed by either side.  In this way, a Tor stream is much like a TCP connection.
One important difference, though, is that with a tor stream, the host that is at the other
side completely invisible, thus to createa Tor stream, we never have to specify the other
side that we would like to connect to, this is decided internally by this layer.  Also, it
never matters what host is on the other side of a Tor stream which has been connected to us.

This layer implements the handling of channel extension and routing.  If a relay cell arrives
which needs to be routed, this happens on this layer and no event is generated for next level
up, the same is true for channel extension.

In order to make this work, we assume that layer 4 has an interface with which it can communicate
with the registration agent.  Specifically, it can query the registration agent for the registry,
and some time later get a response, which if successful will have a sequence of (agentId, hostname, portnum)
triples, or on failure some notification of failure.  Note that this is actually the only place
where our Tor implementation should need to interact with the registration agent, which aside from
responding to these queries should be communicating with the registration server to indicate
that we are alive.

OUTPUT EVENTS TO REGISTRATION AGENT:
getRegistry(requestKey)--generate this event when we need to know the current registry.
                         this will happen whenever we need to establish our Tor circuit,
                         once at the very beginning, and again whenever our circuit goes
                         down due to a node leaving the overlay network.
INPUT EVENTS FROM REGISTRATION AGENT:
registryGotten(requestKey, List<(agentId, hostname, portnum)>)--Registry read was successful,
                                                                we have a sequence of triples
                                                                representing the registry
registryFetchFailed(requestKey)--Registry read failed.  This means that we actually can't
                                 establish a circuit, so we can't be a web proxy, and any
                                 browser that connects to us will not work.  IMO, the best
                                 thing to do in this case is log that we can't contact the
                                 registration server (maybe log to console), and then retry
                                 every 30 seconds or so, logging again for each failure.
                                 This way we will be resilient against
                                 temporary outages of the registration server, when the registration
                                 server comes back, then our web proxy will work again.  In order
                                 to implement this, probably schedule timeouts with layer 0.
                                 (TODO: Add "channel" parameter to layer 0 "schedule timeout",
                                  and then have a "channel" for this layer's use?)
-----END REGISTRATION AGENT INTERFACE------
(Note that this can be implemented with just the output event + callback...)


INPUT EVENTS FROM CHANNEL LAYER:
newChannelCreated(channel)
channelCreationSucceeded(channel, connRequestKey)
channelCreationFailed(connRequestKey)
channelDown(channel)
relayReceivedFromChannel(channel, relaydat)
init()

OUTPUT EVENTS TO CHANNEL LAYER:
createChannel(host, portnum, agentId, connRequestKey)
sendRelayOverChannel(channel, relaydat)
destroyChannel(channel)


INPUT EVENTS FROM ABOVE LAYER:
createStream(host, portnum, connRequestKey)--request the creation of a new stream, which
                                             will tunnel a connection to the (TCP) server
                                             at the given host/portnum
closeStream(stream)--close this stream
sendDataOverStream(stream, data)--send an arbitrarily sized chunk of bytes over
                                  the stream

OUTPUT EVENTS TO ABOVE LAYER:
newStream(stream)--someone else just successfully initiated a new
                   stream connection to us
streamCreationSuccessful(connRequestKey, stream)--an earlier stream creation request
                                                  was successful
streamCreationFailed(connRequestKey)--an earlier stream creation request failed
dataArrivedFromStream(stream, data)--some chunk of data arrived from the Tor stream
streamDown(stream)--the stream closed somehow


IMPLEMENTATION NOTE:  This is the layer where all of the channels are visible, but they
are not visible to the higher layer, so they should be organized here.  Note that all open
channels are one of the following three types:

1.  Endpoint to our circuit--there should always be exactly one of these
2.  Unpaired--this is a channel that was initiated by another agent, but for which we
              have not received a circuit extension request
3.  Paired--A paired channel either started out as an unpaired channel but became paired
            after we received an extension request, or it was a channel that we created
            in response to an extension request.  Either way, each paired channel has exactly
            one other channel with which it is associated, which is also paired.

Note that for the paired channels, any 510 byte relay packet that arrives on one is just
routed to the other, and vice versa (i.e., the relationship is symmetric)

If the layer above requests the creation of new Tor stream, then we use the unique
endpoint to our circuit to do the stream initiation protocol.  We should never recieve
a stream initiation from this channel (if we do, this would be strange, ignore?  Send failure
response? Log?)  Instead, streams initiated by other hosts will come from the set of zero or more unpaired
channels.  We should never initiate streams over these channels.
This is the layer where we'll have to decide what to do if a channel fails for any reason.
Probably:
IF CHANNEL IS OUR CIRCUIT'S ENDPOINT:  Then we need to go through the entire protocol
for setting up a new circuit which was done at the beginning.  Because this involves a sequence
of event generation, probably we will need a "circuit state" object to indicate the state of
our circuit.  If our circuit is anything less than fully established, then we can't reply
to HTTP proxy requests, and need to generate whatever events as we can to make the circuit
established.  ALSO NOTE: Each time the circuit goes down we need to query the registration
agent to rebuild, if it responds great, if it's unresponsive then we're stuck in a state
where we're waiting for registration to be available again, which is fine, we'll just query
again maybe every 30 seconds.
IF CHANNEL IS PAIRED:  Then probably just destroy the channel that it is paired with
IF CHANNEL IS UNPAIRED:  If one of these goes down then we don't care, do nothing

Note that because the initial channel establishment is done at this layer, the init() event
generated by layer 0 is propagated up to this layer.

ALSO NOTE: When a chunk of data is sent, we have a choice to either send immediately,
or buffer and wait for more data before sending. I think probably we should send
immediately, if we want to buffer, though, then definitely we should schedule a timeout,
otherwise there might be a deadlock situation.  I think this is what TCP does, otherwise
HTTP wouldn't work...


